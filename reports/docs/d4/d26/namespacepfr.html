<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebFrame++ ORM: pfr Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WebFrame++ ORM
   &#160;<span id="projectnumber">v2</span>
   </div>
   <div id="projectbrief">C++ Object Relational Mapping Framework for setting up abstract usage of Database</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pfr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d9/d07/namespacepfr_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d07/namespacepfr_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de7/structpfr_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::equal_to like comparator that returns \forcedlink{eq}(x, y)  <a href="../../d1/de7/structpfr_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d70/structpfr_1_1not__equal.html">not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::not_equal like comparator that returns \forcedlink{ne}(x, y)  <a href="../../de/d70/structpfr_1_1not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2d/structpfr_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::greater like comparator that returns \forcedlink{gt}(x, y)  <a href="../../d5/d2d/structpfr_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df3/structpfr_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::less like comparator that returns \forcedlink{lt}(x, y)  <a href="../../d3/df3/structpfr_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dcb/structpfr_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::greater_equal like comparator that returns \forcedlink{ge}(x, y)  <a href="../../df/dcb/structpfr_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d36/structpfr_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::less_equal like comparator that returns \forcedlink{le}(x, y)  <a href="../../d5/d36/structpfr_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0e/structpfr_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::hash like functor that returns \forcedlink{hash_value}(x)  <a href="../../d4/d0e/structpfr_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d05/structpfr_1_1is__reflectable.html">is_reflectable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d63/structpfr_1_1is__reflectable_3_01const_01_t_00_01_what_for_01_4.html">is_reflectable&lt; const T, WhatFor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d63/structpfr_1_1is__reflectable_3_01volatile_01_t_00_01_what_for_01_4.html">is_reflectable&lt; volatile T, WhatFor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d4a/structpfr_1_1is__reflectable_3_01const_01volatile_01_t_00_01_what_for_01_4.html">is_reflectable&lt; const volatile T, WhatFor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a32cb46f4bc1e67246e5ed7e940caa130"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:a32cb46f4bc1e67246e5ed7e940caa130"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a32cb46f4bc1e67246e5ed7e940caa130">tuple_element</a> = <a class="el" href="../../d6/da8/namespacepfr_1_1detail_1_1sequence__tuple.html#a660569e66a44a037796ab1c1df87a49e">detail::sequence_tuple::tuple_element</a>&lt; I, decltype(::<a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">pfr::detail::tie_as_tuple</a>(std::declval&lt; T &amp; &gt;()))&gt;</td></tr>
<tr class="memdesc:a32cb46f4bc1e67246e5ed7e940caa130"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple_element</code> has a member typedef <code>type</code> that returns the type of a field with index I in \aggregate T.  <a href="../../d4/d26/namespacepfr.html#a32cb46f4bc1e67246e5ed7e940caa130">More...</a><br /></td></tr>
<tr class="separator:a32cb46f4bc1e67246e5ed7e940caa130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108255eaa4d429a329a174cf49f27344"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:a108255eaa4d429a329a174cf49f27344"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a108255eaa4d429a329a174cf49f27344">tuple_element_t</a> = typename <a class="el" href="../../d4/d26/namespacepfr.html#a32cb46f4bc1e67246e5ed7e940caa130">tuple_element</a>&lt; I, T &gt;::type</td></tr>
<tr class="memdesc:a108255eaa4d429a329a174cf49f27344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a field with index <code>I</code> in \aggregate <code>T</code>.  <a href="../../d4/d26/namespacepfr.html#a108255eaa4d429a329a174cf49f27344">More...</a><br /></td></tr>
<tr class="separator:a108255eaa4d429a329a174cf49f27344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9aaaded645f54bdd6373947424b576"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b9aaaded645f54bdd6373947424b576"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a8b9aaaded645f54bdd6373947424b576">tuple_size</a> = <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa3caea0fc58618a14b4c3e9afa96a101">detail::size_t_</a>&lt; <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a521adf9b00f9b3944649066dd955c8c7">pfr::detail::fields_count</a>&lt; T &gt;()&gt;</td></tr>
<tr class="separator:a8b9aaaded645f54bdd6373947424b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe20d386bead4320f09ff3a69afa8bfd"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:abe20d386bead4320f09ff3a69afa8bfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#abe20d386bead4320f09ff3a69afa8bfd">get</a> (const T &amp;val) noexcept</td></tr>
<tr class="memdesc:abe20d386bead4320f09ff3a69afa8bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference or const reference to a field with index <code>I</code> in \aggregate <code>val</code>. Overload taking the type <code>U</code> returns reference or const reference to a field with provided type <code>U</code> in \aggregate <code>val</code> if there's only one field of such type in <code>val</code>.  <a href="../../d4/d26/namespacepfr.html#abe20d386bead4320f09ff3a69afa8bfd">More...</a><br /></td></tr>
<tr class="separator:abe20d386bead4320f09ff3a69afa8bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1c56e1b72ba3d26b6ba09e670af80f"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:a4f1c56e1b72ba3d26b6ba09e670af80f"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a4f1c56e1b72ba3d26b6ba09e670af80f">get</a> (T &amp;val, std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a4f1c56e1b72ba3d26b6ba09e670af80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c448163d54466f567e94d23397fb281"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:a9c448163d54466f567e94d23397fb281"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a9c448163d54466f567e94d23397fb281">get</a> (T &amp;, std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a9c448163d54466f567e94d23397fb281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed4515ffe116a221c0c9498dab94269"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T &gt; </td></tr>
<tr class="memitem:a1ed4515ffe116a221c0c9498dab94269"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a1ed4515ffe116a221c0c9498dab94269">get</a> (T &amp;&amp;val, std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a1ed4515ffe116a221c0c9498dab94269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964e4be19d25e693c4b5e2ac02ca30cd"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a964e4be19d25e693c4b5e2ac02ca30cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr const U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a964e4be19d25e693c4b5e2ac02ca30cd">get</a> (const T &amp;val) noexcept</td></tr>
<tr class="separator:a964e4be19d25e693c4b5e2ac02ca30cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1547f7359c2fdee383cefee63039f9"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a0a1547f7359c2fdee383cefee63039f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a0a1547f7359c2fdee383cefee63039f9">get</a> (T &amp;val, std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a0a1547f7359c2fdee383cefee63039f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0ee4f470cb4c42238db732837bfc8"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a11b0ee4f470cb4c42238db732837bfc8"><td class="memTemplItemLeft" align="right" valign="top">constexpr U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a11b0ee4f470cb4c42238db732837bfc8">get</a> (T &amp;, std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a11b0ee4f470cb4c42238db732837bfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6f1079dedf5373d69d54bf9f360e7a"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:aff6f1079dedf5373d69d54bf9f360e7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr U &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#aff6f1079dedf5373d69d54bf9f360e7a">get</a> (T &amp;&amp;val, std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:aff6f1079dedf5373d69d54bf9f360e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02731b2fc23581c2b67b9889451ccb6a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a02731b2fc23581c2b67b9889451ccb6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a02731b2fc23581c2b67b9889451ccb6a">structure_to_tuple</a> (const T &amp;val) noexcept</td></tr>
<tr class="memdesc:a02731b2fc23581c2b67b9889451ccb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::tuple</code> from fields of an \aggregate <code>val</code>.  <a href="../../d4/d26/namespacepfr.html#a02731b2fc23581c2b67b9889451ccb6a">More...</a><br /></td></tr>
<tr class="separator:a02731b2fc23581c2b67b9889451ccb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adc9d30f52fbb7567415da40ad94349"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3adc9d30f52fbb7567415da40ad94349"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a3adc9d30f52fbb7567415da40ad94349">structure_tie</a> (const T &amp;val) noexcept</td></tr>
<tr class="memdesc:a3adc9d30f52fbb7567415da40ad94349"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tie` like function that ties fields of a structure.  <a href="../../d4/d26/namespacepfr.html#a3adc9d30f52fbb7567415da40ad94349">More...</a><br /></td></tr>
<tr class="separator:a3adc9d30f52fbb7567415da40ad94349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0e0814a4fdddddd54f03f5e87c9c24"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f0e0814a4fdddddd54f03f5e87c9c24"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a5f0e0814a4fdddddd54f03f5e87c9c24">structure_tie</a> (T &amp;val, std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:a5f0e0814a4fdddddd54f03f5e87c9c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8fb6fb205d497c54085adb6ea932f2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afe8fb6fb205d497c54085adb6ea932f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#afe8fb6fb205d497c54085adb6ea932f2">structure_tie</a> (T &amp;, std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:afe8fb6fb205d497c54085adb6ea932f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8974aa361c400a576ef9193d6cffd40"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab8974aa361c400a576ef9193d6cffd40"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#ab8974aa361c400a576ef9193d6cffd40">structure_tie</a> (T &amp;&amp;, std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *=nullptr) noexcept</td></tr>
<tr class="separator:ab8974aa361c400a576ef9193d6cffd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22aa54f54e0c4294dbb685991530d4a"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:ae22aa54f54e0c4294dbb685991530d4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#ae22aa54f54e0c4294dbb685991530d4a">for_each_field</a> (T &amp;&amp;value, F &amp;&amp;func)</td></tr>
<tr class="separator:ae22aa54f54e0c4294dbb685991530d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d4b2ba9c7e94a210ea381971bb3499"><td class="memTemplParams" colspan="2">template&lt;typename... Elements&gt; </td></tr>
<tr class="memitem:a11d4b2ba9c7e94a210ea381971bb3499"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/ddb/structpfr_1_1detail_1_1tie__from__structure__tuple.html">detail::tie_from_structure_tuple</a>&lt; Elements... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a11d4b2ba9c7e94a210ea381971bb3499">tie_from_structure</a> (Elements &amp;... args) noexcept</td></tr>
<tr class="memdesc:a11d4b2ba9c7e94a210ea381971bb3499"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tie-like function that allows assigning to tied values from aggregates.  <a href="../../d4/d26/namespacepfr.html#a11d4b2ba9c7e94a210ea381971bb3499">More...</a><br /></td></tr>
<tr class="separator:a11d4b2ba9c7e94a210ea381971bb3499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0ab71336af57f60cddc0ad590912a1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4a0ab71336af57f60cddc0ad590912a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a4a0ab71336af57f60cddc0ad590912a1">io</a> (T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:a4a0ab71336af57f60cddc0ad590912a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290c44ac8f450c2aacd7b73ef4c08b42"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a290c44ac8f450c2aacd7b73ef4c08b42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a290c44ac8f450c2aacd7b73ef4c08b42">io_fields</a> (T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:a290c44ac8f450c2aacd7b73ef4c08b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff90c56b2eef3087edca1ed7aeda6747"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aff90c56b2eef3087edca1ed7aeda6747"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a732f66c646496043dd7da5949b736440">detail::enable_not_eq_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#aff90c56b2eef3087edca1ed7aeda6747">eq</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aff90c56b2eef3087edca1ed7aeda6747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for equality using their own comparison and conversion operators; if no operators avalable returns \forcedlink{eq_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#aff90c56b2eef3087edca1ed7aeda6747">More...</a><br /></td></tr>
<tr class="separator:aff90c56b2eef3087edca1ed7aeda6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f0c552903771532367be912cd462e1"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad3f0c552903771532367be912cd462e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa4af3cba890bec3b92194ff9f549cb7f">detail::enable_eq_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#ad3f0c552903771532367be912cd462e1">eq</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:ad3f0c552903771532367be912cd462e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca529814463f7e95184f1390385af8dc"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aca529814463f7e95184f1390385af8dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa4cfc747df3957e8d03ce6ee8bab1294">detail::enable_not_ne_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#aca529814463f7e95184f1390385af8dc">ne</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aca529814463f7e95184f1390385af8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for inequality using their own comparison and conversion operators; if no operators avalable returns \forcedlink{ne_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#aca529814463f7e95184f1390385af8dc">More...</a><br /></td></tr>
<tr class="separator:aca529814463f7e95184f1390385af8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365061baaca2655bbed16d395f658943"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a365061baaca2655bbed16d395f658943"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a8f8edab77e7b9b4f08371b0e495836c1">detail::enable_ne_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a365061baaca2655bbed16d395f658943">ne</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:a365061baaca2655bbed16d395f658943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7710701d20486d74c27aab89bb5d1766"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7710701d20486d74c27aab89bb5d1766"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#abf62b904bdbf38b80f00f342b035ff66">detail::enable_not_lt_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a7710701d20486d74c27aab89bb5d1766">lt</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7710701d20486d74c27aab89bb5d1766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for less-than using their own comparison and conversion operators; if no operators avalable returns \forcedlink{lt_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#a7710701d20486d74c27aab89bb5d1766">More...</a><br /></td></tr>
<tr class="separator:a7710701d20486d74c27aab89bb5d1766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6fe74582b0a888d13239fe2f780813"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7e6fe74582b0a888d13239fe2f780813"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a2f34d94864c1c8d219f74a2201615d0b">detail::enable_lt_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a7e6fe74582b0a888d13239fe2f780813">lt</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:a7e6fe74582b0a888d13239fe2f780813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afeec9caa76017f410b51344e58a0fd"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8afeec9caa76017f410b51344e58a0fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a78ac43b9b9dfec3f4717d11f169be8b3">detail::enable_not_gt_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a8afeec9caa76017f410b51344e58a0fd">gt</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8afeec9caa76017f410b51344e58a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for greater-than using their own comparison and conversion operators; if no operators avalable returns \forcedlink{lt_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#a8afeec9caa76017f410b51344e58a0fd">More...</a><br /></td></tr>
<tr class="separator:a8afeec9caa76017f410b51344e58a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6454b7bb4a8cf8f656e71240a033c2"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:acb6454b7bb4a8cf8f656e71240a033c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a700286e7e85437bfec8055cc78e145a8">detail::enable_gt_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#acb6454b7bb4a8cf8f656e71240a033c2">gt</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:acb6454b7bb4a8cf8f656e71240a033c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c6741531299366f77d04329d02fc0"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af30c6741531299366f77d04329d02fc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a4d9c3f1d988b1e38d9ff2d95a96a4f07">detail::enable_not_le_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#af30c6741531299366f77d04329d02fc0">le</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af30c6741531299366f77d04329d02fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for less-equal using their own comparison and conversion operators; if no operators avalable returns \forcedlink{le_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#af30c6741531299366f77d04329d02fc0">More...</a><br /></td></tr>
<tr class="separator:af30c6741531299366f77d04329d02fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c44a96e23f8641a15a4f1c6faf0818"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a47c44a96e23f8641a15a4f1c6faf0818"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a6e6e479074182d99ca001ae7985b2213">detail::enable_le_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a47c44a96e23f8641a15a4f1c6faf0818">le</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:a47c44a96e23f8641a15a4f1c6faf0818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb758afcad49d19724eb8eb5f283ff"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a19cb758afcad49d19724eb8eb5f283ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aca1fba6fcc68233fbeed69265f53bf60">detail::enable_not_ge_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a19cb758afcad49d19724eb8eb5f283ff">ge</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a19cb758afcad49d19724eb8eb5f283ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for greater-equal using their own comparison and conversion operators; if no operators avalable returns \forcedlink{ge_fields}(lhs, rhs).  <a href="../../d4/d26/namespacepfr.html#a19cb758afcad49d19724eb8eb5f283ff">More...</a><br /></td></tr>
<tr class="separator:a19cb758afcad49d19724eb8eb5f283ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6656d49af7cde88caef5f260dc1680f"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab6656d49af7cde88caef5f260dc1680f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#acf4189fc0e7353eb527ba6a6ef0b90c4">detail::enable_ge_comp_t</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#ab6656d49af7cde88caef5f260dc1680f">ge</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:ab6656d49af7cde88caef5f260dc1680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a773758d1362bfe66b3e9150a515b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa68a773758d1362bfe66b3e9150a515b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a42cea6703fcec18015ac175b45895987">detail::enable_not_hashable_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#aa68a773758d1362bfe66b3e9150a515b">hash_value</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:aa68a773758d1362bfe66b3e9150a515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes value using its own std::hash specialization; if no std::hash specialization avalable returns \forcedlink{hash_fields}(value).  <a href="../../d4/d26/namespacepfr.html#aa68a773758d1362bfe66b3e9150a515b">More...</a><br /></td></tr>
<tr class="separator:aa68a773758d1362bfe66b3e9150a515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd676e0dd54b2e1223c73f1a046bcea"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8bd676e0dd54b2e1223c73f1a046bcea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a992c82ebb200060670efcb732d598ff8">detail::enable_hashable_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a8bd676e0dd54b2e1223c73f1a046bcea">hash_value</a> (const T &amp;value)</td></tr>
<tr class="separator:a8bd676e0dd54b2e1223c73f1a046bcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69295b21d3d16035aa398f8d0f93e24d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a69295b21d3d16035aa398f8d0f93e24d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a69295b21d3d16035aa398f8d0f93e24d">eq_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a69295b21d3d16035aa398f8d0f93e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d46ae2f6c074ad43b3837746f2a75"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a171d46ae2f6c074ad43b3837746f2a75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a171d46ae2f6c074ad43b3837746f2a75">ne_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a171d46ae2f6c074ad43b3837746f2a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48b819486481c5cb1d7b542f368c50"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a2a48b819486481c5cb1d7b542f368c50"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a2a48b819486481c5cb1d7b542f368c50">gt_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a2a48b819486481c5cb1d7b542f368c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363e8c1946f33a73b5d1ab84f99d163"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa363e8c1946f33a73b5d1ab84f99d163"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#aa363e8c1946f33a73b5d1ab84f99d163">lt_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:aa363e8c1946f33a73b5d1ab84f99d163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcfd632d43191d0d80d20c0af3e06f6"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4bcfd632d43191d0d80d20c0af3e06f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a4bcfd632d43191d0d80d20c0af3e06f6">ge_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a4bcfd632d43191d0d80d20c0af3e06f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f48feef39cc798975866b326e04f5dd"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9f48feef39cc798975866b326e04f5dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a9f48feef39cc798975866b326e04f5dd">le_fields</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a9f48feef39cc798975866b326e04f5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445a38384130d62cc8a00b9e86c9d1c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a445a38384130d62cc8a00b9e86c9d1c1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a445a38384130d62cc8a00b9e86c9d1c1">hash_fields</a> (const T &amp;x)</td></tr>
<tr class="separator:a445a38384130d62cc8a00b9e86c9d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e6c3763a793e6e07d1341337db70925"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e6c3763a793e6e07d1341337db70925"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d26/namespacepfr.html#a6e6c3763a793e6e07d1341337db70925">tuple_size_v</a> = <a class="el" href="../../d4/d26/namespacepfr.html#a8b9aaaded645f54bdd6373947424b576">tuple_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6e6c3763a793e6e07d1341337db70925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a32cb46f4bc1e67246e5ed7e940caa130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb46f4bc1e67246e5ed7e940caa130">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d26/namespacepfr.html#a32cb46f4bc1e67246e5ed7e940caa130">pfr::tuple_element</a> = typedef <a class="el" href="../../d6/da8/namespacepfr_1_1detail_1_1sequence__tuple.html#a660569e66a44a037796ab1c1df87a49e">detail::sequence_tuple::tuple_element</a>&lt;I, decltype(::<a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">pfr::detail::tie_as_tuple</a>(std::declval&lt;T&amp;&gt;()))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple_element</code> has a member typedef <code>type</code> that returns the type of a field with index I in \aggregate T. </p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">std::vector&lt; pfr::tuple_element&lt;0, my_structure&gt;::type &gt; v;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00121">121</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="a108255eaa4d429a329a174cf49f27344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108255eaa4d429a329a174cf49f27344">&#9670;&nbsp;</a></span>tuple_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d26/namespacepfr.html#a108255eaa4d429a329a174cf49f27344">pfr::tuple_element_t</a> = typedef typename <a class="el" href="../../d4/d26/namespacepfr.html#a32cb46f4bc1e67246e5ed7e940caa130">tuple_element</a>&lt;I, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a field with index <code>I</code> in \aggregate <code>T</code>. </p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">std::vector&lt; pfr::tuple_element_t&lt;0, my_structure&gt; &gt; v;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00129">129</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="a8b9aaaded645f54bdd6373947424b576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9aaaded645f54bdd6373947424b576">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d26/namespacepfr.html#a8b9aaaded645f54bdd6373947424b576">pfr::tuple_size</a> = typedef <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa3caea0fc58618a14b4c3e9afa96a101">detail::size_t_</a>&lt;<a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a521adf9b00f9b3944649066dd955c8c7">pfr::detail::fields_count</a>&lt;T&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Has a static const member variable <code>value</code> that contains fields count in a T. Works for any T that satisfies \aggregate.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">std::array&lt;int, pfr::tuple_size&lt;my_structure&gt;::value &gt; a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../d4/d41/tuple__size_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d4/d41/tuple__size_8hpp_source.html">tuple_size.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad3f0c552903771532367be912cd462e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f0c552903771532367be912cd462e1">&#9670;&nbsp;</a></span>eq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa4af3cba890bec3b92194ff9f549cb7f">detail::enable_eq_comp_t</a>&lt;T, U&gt; pfr::eq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00080">80</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">return</span> lhs == rhs;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff90c56b2eef3087edca1ed7aeda6747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff90c56b2eef3087edca1ed7aeda6747">&#9670;&nbsp;</a></span>eq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a732f66c646496043dd7da5949b736440">detail::enable_not_eq_comp_t</a>&lt;T, U&gt; pfr::eq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for equality using their own comparison and conversion operators; if no operators avalable returns \forcedlink{eq_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is equal to rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00074">74</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a69295b21d3d16035aa398f8d0f93e24d">pfr::eq_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a69295b21d3d16035aa398f8d0f93e24d"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a69295b21d3d16035aa398f8d0f93e24d">pfr::eq_fields</a></div><div class="ttdeci">constexpr bool eq_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00042">ops_fields.hpp:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a69295b21d3d16035aa398f8d0f93e24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69295b21d3d16035aa398f8d0f93e24d">&#9670;&nbsp;</a></span>eq_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::eq_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field equality comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L == R &amp;&amp; tuple_size_v&lt;T&gt; == tuple_size_v&lt;U&gt;</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::equal_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae22aa54f54e0c4294dbb685991530d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22aa54f54e0c4294dbb685991530d4a">&#9670;&nbsp;</a></span>for_each_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pfr::for_each_field </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <code>func</code> for each field of a <code>value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>must have one of the following signatures:<ul>
<li>any_return_type func(U&amp;&amp; field) // field of value is perfect forwarded to function</li>
<li>any_return_type func(U&amp;&amp; field, std::size_t i)</li>
<li>any_return_type func(U&amp;&amp; value, I i) // Here I is an <code>std::integral_constant&lt;size_t, field_index&gt;</code></li>
</ul>
</td></tr>
    <tr><td class="paramname">value</td><td>To each field of this variable will be the <code>func</code> applied.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_struct { <span class="keywordtype">int</span> i, <span class="keywordtype">short</span> s; };</div>
<div class="line"><span class="keywordtype">int</span> sum = 0;</div>
<div class="line"><a class="code" href="../../d4/d26/namespacepfr.html#ae22aa54f54e0c4294dbb685991530d4a">pfr::for_each_field</a>(my_struct{20, 22}, [&amp;sum](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; field) { sum += field; });</div>
<div class="line">assert(sum == 42);</div>
<div class="ttc" id="anamespacepfr_html_ae22aa54f54e0c4294dbb685991530d4a"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#ae22aa54f54e0c4294dbb685991530d4a">pfr::for_each_field</a></div><div class="ttdeci">void for_each_field(T &amp;&amp;value, F &amp;&amp;func)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d47/core_8hpp_source.html#l00212">core.hpp:212</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00212">212</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        constexpr std::size_t fields_count_val = pfr::detail::fields_count&lt;std::remove_reference_t&lt;T&gt;&gt;();</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160; </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#a47fc6565c89bad2c6952b0de06342f4b">::pfr::detail::for_each_field_dispatcher</a>(</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            value,</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            [f = std::forward&lt;F&gt;(func)](<span class="keyword">auto</span>&amp;&amp; t) <span class="keyword">mutable</span> {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                <span class="comment">// MSVC related workaround. Its lambdas do not capture constexprs.</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                constexpr std::size_t fields_count_val_in_lambda = pfr::detail::fields_count&lt;std::remove_reference_t&lt;T&gt;&gt;();</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160; </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae1aaaccd64e87c9c8d92b0a97523a5ed">::pfr::detail::for_each_field_impl</a>(</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    t, std::forward&lt;F&gt;(f), detail::make_index_sequence&lt;fields_count_val_in_lambda&gt;{}, std::is_rvalue_reference&lt;T&amp;&amp;&gt;{});</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            },</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            detail::make_index_sequence&lt;fields_count_val&gt;{});</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_a47fc6565c89bad2c6952b0de06342f4b"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#a47fc6565c89bad2c6952b0de06342f4b">pfr::detail::for_each_field_dispatcher</a></div><div class="ttdeci">void for_each_field_dispatcher(T &amp;t, F &amp;&amp;f, std::index_sequence&lt; I... &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/d54/core14__classic_8hpp_source.html#l00660">core14_classic.hpp:660</a></div></div>
<div class="ttc" id="anamespacepfr_1_1detail_html_ae1aaaccd64e87c9c8d92b0a97523a5ed"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#ae1aaaccd64e87c9c8d92b0a97523a5ed">pfr::detail::for_each_field_impl</a></div><div class="ttdeci">void for_each_field_impl(T &amp;t, F &amp;&amp;f, std::index_sequence&lt; I... &gt;, std::false_type)</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d44/for__each__field__impl_8hpp_source.html#l00036">for_each_field_impl.hpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6656d49af7cde88caef5f260dc1680f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6656d49af7cde88caef5f260dc1680f">&#9670;&nbsp;</a></span>ge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#acf4189fc0e7353eb527ba6a6ef0b90c4">detail::enable_ge_comp_t</a>&lt;T, U&gt; pfr::ge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00155">155</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">return</span> lhs &gt;= rhs;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19cb758afcad49d19724eb8eb5f283ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cb758afcad49d19724eb8eb5f283ff">&#9670;&nbsp;</a></span>ge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aca1fba6fcc68233fbeed69265f53bf60">detail::enable_not_ge_comp_t</a>&lt;T, U&gt; pfr::ge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for greater-equal using their own comparison and conversion operators; if no operators avalable returns \forcedlink{ge_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is greater or equal to rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00149">149</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a4bcfd632d43191d0d80d20c0af3e06f6">pfr::ge_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a4bcfd632d43191d0d80d20c0af3e06f6"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a4bcfd632d43191d0d80d20c0af3e06f6">pfr::ge_fields</a></div><div class="ttdeci">constexpr bool ge_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00082">ops_fields.hpp:82</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bcfd632d43191d0d80d20c0af3e06f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcfd632d43191d0d80d20c0af3e06f6">&#9670;&nbsp;</a></span>ge_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::ge_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field greater equal comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt;= tuple_size_v&lt;U&gt;)</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00082">82</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::greater_equal_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abe20d386bead4320f09ff3a69afa8bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe20d386bead4320f09ff3a69afa8bfd">&#9670;&nbsp;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) pfr::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference or const reference to a field with index <code>I</code> in \aggregate <code>val</code>. Overload taking the type <code>U</code> returns reference or const reference to a field with provided type <code>U</code> in \aggregate <code>val</code> if there's only one field of such type in <code>val</code>. </p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_struct { <span class="keywordtype">int</span> i, <span class="keywordtype">short</span> s; };</div>
<div class="line">my_struct s {10, 11};</div>
<div class="line"> </div>
<div class="line">assert(pfr::get&lt;0&gt;(s) == 10);</div>
<div class="line">pfr::get&lt;1&gt;(s) = 0;</div>
<div class="line"> </div>
<div class="line">assert(pfr::get&lt;int&gt;(s) == 10);</div>
<div class="line">pfr::get&lt;short&gt;(s) = 11;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">return</span> detail::sequence_tuple::get&lt;I&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_ae4a6f202c475b551fd2a84a8cc35c9c5"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">pfr::detail::tie_as_tuple</a></div><div class="ttdeci">auto tie_as_tuple(T &amp;val) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/d54/core14__classic_8hpp_source.html#l00568">core14_classic.hpp:568</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a964e4be19d25e693c4b5e2ac02ca30cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964e4be19d25e693c4b5e2ac02ca30cd">&#9670;&nbsp;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const U&amp; pfr::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00082">82</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">return</span> detail::sequence_tuple::get_by_type_impl&lt;const U&amp;&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val));</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ed4515ffe116a221c0c9498dab94269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed4515ffe116a221c0c9498dab94269">&#9670;&nbsp;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00076">76</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keywordflow">return</span> std::move(detail::sequence_tuple::get&lt;I&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val)));</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff6f1079dedf5373d69d54bf9f360e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6f1079dedf5373d69d54bf9f360e7a">&#9670;&nbsp;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U&amp;&amp; pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00110">110</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> std::move(detail::sequence_tuple::get_by_type_impl&lt;U&amp;&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val)));</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c448163d54466f567e94d23397fb281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c448163d54466f567e94d23397fb281">&#9670;&nbsp;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00068">68</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        static_assert(<span class="keyword">sizeof</span>(T) &amp;&amp; <span class="keyword">false</span>, <span class="stringliteral">&quot;====================&gt; Boost.PFR: Calling pfr::get on non const non assignable type is allowed only in C++17&quot;</span>);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11b0ee4f470cb4c42238db732837bfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b0ee4f470cb4c42238db732837bfc8">&#9670;&nbsp;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U&amp; pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00102">102</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        static_assert(<span class="keyword">sizeof</span>(T) &amp;&amp; <span class="keyword">false</span>, <span class="stringliteral">&quot;====================&gt; Boost.PFR: Calling pfr::get on non const non assignable type is allowed only in C++17&quot;</span>);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f1c56e1b72ba3d26b6ba09e670af80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1c56e1b72ba3d26b6ba09e670af80f">&#9670;&nbsp;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">return</span> detail::sequence_tuple::get&lt;I&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val));</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a1547f7359c2fdee383cefee63039f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1547f7359c2fdee383cefee63039f9">&#9670;&nbsp;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U&amp; pfr::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00089">89</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">return</span> detail::sequence_tuple::get_by_type_impl&lt;U&amp;&gt;(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val));</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acb6454b7bb4a8cf8f656e71240a033c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6454b7bb4a8cf8f656e71240a033c2">&#9670;&nbsp;</a></span>gt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a700286e7e85437bfec8055cc78e145a8">detail::enable_gt_comp_t</a>&lt;T, U&gt; pfr::gt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00125">125</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordflow">return</span> lhs &gt; rhs;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8afeec9caa76017f410b51344e58a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afeec9caa76017f410b51344e58a0fd">&#9670;&nbsp;</a></span>gt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a78ac43b9b9dfec3f4717d11f169be8b3">detail::enable_not_gt_comp_t</a>&lt;T, U&gt; pfr::gt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for greater-than using their own comparison and conversion operators; if no operators avalable returns \forcedlink{lt_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is greater than rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00119">119</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a2a48b819486481c5cb1d7b542f368c50">pfr::gt_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a2a48b819486481c5cb1d7b542f368c50"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a2a48b819486481c5cb1d7b542f368c50">pfr::gt_fields</a></div><div class="ttdeci">constexpr bool gt_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00062">ops_fields.hpp:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a48b819486481c5cb1d7b542f368c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a48b819486481c5cb1d7b542f368c50">&#9670;&nbsp;</a></span>gt_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::gt_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field greter comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt; tuple_size_v&lt;U&gt;)</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00062">62</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::greater_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a445a38384130d62cc8a00b9e86c9d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445a38384130d62cc8a00b9e86c9d1c1">&#9670;&nbsp;</a></span>hash_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pfr::hash_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does a field-by-field hashing.</p>
<dl class="section return"><dt>Returns</dt><dd>combined hash of all the fields </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00100">100</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        constexpr std::size_t fields_count_val = pfr::detail::fields_count&lt;std::remove_reference_t&lt;T&gt;&gt;();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="preprocessor">#if PFR_USE_CPP17 || PFR_USE_LOOPHOLE</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">return</span> detail::hash_impl&lt;0, fields_count_val&gt;::compute(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(x));</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        std::size_t result = 0;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#a47fc6565c89bad2c6952b0de06342f4b">::pfr::detail::for_each_field_dispatcher</a>(</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            x,</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            [&amp;result](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lhs) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <span class="comment">// We can not reuse `fields_count_val` in lambda because compilers had issues with</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                <span class="comment">// passing constexpr variables into lambdas. Computing is again is the most portable solution.</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                constexpr std::size_t fields_count_val_lambda = pfr::detail::fields_count&lt;std::remove_reference_t&lt;T&gt;&gt;();</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                result = detail::hash_impl&lt;0, fields_count_val_lambda&gt;::compute(lhs);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            },</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            detail::make_index_sequence&lt;fields_count_val&gt;{});</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160; </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bd676e0dd54b2e1223c73f1a046bcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd676e0dd54b2e1223c73f1a046bcea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a992c82ebb200060670efcb732d598ff8">detail::enable_hashable_t</a>&lt;T&gt; pfr::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00169">169</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">return</span> std::hash&lt;T&gt;{}(value);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa68a773758d1362bfe66b3e9150a515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68a773758d1362bfe66b3e9150a515b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a42cea6703fcec18015ac175b45895987">detail::enable_not_hashable_t</a>&lt;T&gt; pfr::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes value using its own std::hash specialization; if no std::hash specialization avalable returns \forcedlink{hash_fields}(value). </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t with hash of the value </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00163">163</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a445a38384130d62cc8a00b9e86c9d1c1">pfr::hash_fields</a>(value);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a445a38384130d62cc8a00b9e86c9d1c1"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a445a38384130d62cc8a00b9e86c9d1c1">pfr::hash_fields</a></div><div class="ttdeci">std::size_t hash_fields(const T &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00100">ops_fields.hpp:100</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a0ab71336af57f60cddc0ad590912a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0ab71336af57f60cddc0ad590912a1">&#9670;&nbsp;</a></span>io()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto pfr::io </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>IO manipulator to read/write \aggregate <code>value</code> using its IO stream operators or using \forcedlink{io_fields} if operators are not available.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_struct { <span class="keywordtype">int</span> i; <span class="keywordtype">short</span> s; };</div>
<div class="line">my_struct x;</div>
<div class="line">std::stringstream ss;</div>
<div class="line">ss &lt;&lt; <span class="stringliteral">&quot;{ 12, 13 }&quot;</span>;</div>
<div class="line">ss &gt;&gt; <a class="code" href="../../d4/d26/namespacepfr.html#a4a0ab71336af57f60cddc0ad590912a1">pfr::io</a>(x);</div>
<div class="line">assert(x.i == 12);</div>
<div class="line">assert(x.s == 13);</div>
<div class="ttc" id="anamespacepfr_html_a4a0ab71336af57f60cddc0ad590912a1"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a4a0ab71336af57f60cddc0ad590912a1">pfr::io</a></div><div class="ttdeci">auto io(T &amp;&amp;value) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dc6/io_8hpp_source.html#l00099">io.hpp:99</a></div></div>
</div><!-- fragment --><p>\customio </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dc6/io_8hpp_source.html#l00099">99</a> of file <a class="el" href="../../d2/dc6/io_8hpp_source.html">io.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">return</span> detail::io_impl&lt;T&gt;{std::forward&lt;T&gt;(value)};</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a290c44ac8f450c2aacd7b73ef4c08b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290c44ac8f450c2aacd7b73ef4c08b42">&#9670;&nbsp;</a></span>io_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto pfr::io_fields </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>IO manipulator to read/write \aggregate <code>value</code> field-by-field.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_struct {</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">short</span> s;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::ostream&amp; <a class="code" href="../../dd/d8d/namespacewebframe_1_1_o_r_m_1_1_c_r_u_d_1_1details.html#ae0d849599a9e3995b93d84b42a25f6bc">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> my_struct&amp; x) {</div>
<div class="line">    <span class="keywordflow">return</span> os &lt;&lt; <a class="code" href="../../d4/d26/namespacepfr.html#a290c44ac8f450c2aacd7b73ef4c08b42">pfr::io_fields</a>(x);  <span class="comment">// Equivalent to: os &lt;&lt; &quot;{ &quot; &lt;&lt; x.i &lt;&lt; &quot; ,&quot; &lt;&lt;  x.s &lt;&lt; &quot; }&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::istream&amp; <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#aa5a35b4556620ea49c833b461254d82f">operator&gt;&gt;</a>(std::istream&amp; is, my_struct&amp; x) {</div>
<div class="line">    <span class="keywordflow">return</span> is &gt;&gt; <a class="code" href="../../d4/d26/namespacepfr.html#a290c44ac8f450c2aacd7b73ef4c08b42">pfr::io_fields</a>(x);  <span class="comment">// Equivalent to: is &gt;&gt; &quot;{ &quot; &gt;&gt; x.i &gt;&gt; &quot; ,&quot; &gt;&gt;  x.s &gt;&gt; &quot; }&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_aa5a35b4556620ea49c833b461254d82f"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#aa5a35b4556620ea49c833b461254d82f">pfr::detail::operator&gt;&gt;</a></div><div class="ttdeci">enable_not_istreamable_t&lt; std::basic_istream&lt; Char, Traits &gt;, T &gt; operator&gt;&gt;(std::basic_istream&lt; Char, Traits &gt; &amp;in, io_impl&lt; T &gt; &amp;&amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dc6/io_8hpp_source.html#l00072">io.hpp:72</a></div></div>
<div class="ttc" id="anamespacepfr_html_a290c44ac8f450c2aacd7b73ef4c08b42"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a290c44ac8f450c2aacd7b73ef4c08b42">pfr::io_fields</a></div><div class="ttdeci">auto io_fields(T &amp;&amp;value) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/de7/io__fields_8hpp_source.html#l00165">io_fields.hpp:165</a></div></div>
<div class="ttc" id="anamespacewebframe_1_1_o_r_m_1_1_c_r_u_d_1_1details_html_ae0d849599a9e3995b93d84b42a25f6bc"><div class="ttname"><a href="../../dd/d8d/namespacewebframe_1_1_o_r_m_1_1_c_r_u_d_1_1details.html#ae0d849599a9e3995b93d84b42a25f6bc">webframe::ORM::CRUD::details::operator&lt;&lt;</a></div><div class="ttdeci">auto operator&lt;&lt;(DB db, const QueryType query)</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d93/utils_8hpp_source.html#l00279">utils.hpp:279</a></div></div>
</div><!-- fragment --><p>Input and output streaming operators for <code><a class="el" href="../../d4/d26/namespacepfr.html#a290c44ac8f450c2aacd7b73ef4c08b42">pfr::io_fields</a></code> are symmetric, meaning that you get the original value by streaming it and reading back if each fields streaming operator is symmetric.</p>
<p>\customio </p>

<p class="definition">Definition at line <a class="el" href="../../dd/de7/io__fields_8hpp_source.html#l00165">165</a> of file <a class="el" href="../../dd/de7/io__fields_8hpp_source.html">io_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">return</span> detail::io_fields_impl&lt;T&gt;{std::forward&lt;T&gt;(value)};</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a47c44a96e23f8641a15a4f1c6faf0818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c44a96e23f8641a15a4f1c6faf0818">&#9670;&nbsp;</a></span>le() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a6e6e479074182d99ca001ae7985b2213">detail::enable_le_comp_t</a>&lt;T, U&gt; pfr::le </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00140">140</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">return</span> lhs &lt;= rhs;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af30c6741531299366f77d04329d02fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30c6741531299366f77d04329d02fc0">&#9670;&nbsp;</a></span>le() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a4d9c3f1d988b1e38d9ff2d95a96a4f07">detail::enable_not_le_comp_t</a>&lt;T, U&gt; pfr::le </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for less-equal using their own comparison and conversion operators; if no operators avalable returns \forcedlink{le_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is less or equal to rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00134">134</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a9f48feef39cc798975866b326e04f5dd">pfr::le_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a9f48feef39cc798975866b326e04f5dd"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a9f48feef39cc798975866b326e04f5dd">pfr::le_fields</a></div><div class="ttdeci">constexpr bool le_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00092">ops_fields.hpp:92</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f48feef39cc798975866b326e04f5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f48feef39cc798975866b326e04f5dd">&#9670;&nbsp;</a></span>le_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::le_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field less equal comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt;= tuple_size_v&lt;U&gt;)</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00092">92</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::less_equal_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e6fe74582b0a888d13239fe2f780813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6fe74582b0a888d13239fe2f780813">&#9670;&nbsp;</a></span>lt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a2f34d94864c1c8d219f74a2201615d0b">detail::enable_lt_comp_t</a>&lt;T, U&gt; pfr::lt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00110">110</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> lhs &lt; rhs;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7710701d20486d74c27aab89bb5d1766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7710701d20486d74c27aab89bb5d1766">&#9670;&nbsp;</a></span>lt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#abf62b904bdbf38b80f00f342b035ff66">detail::enable_not_lt_comp_t</a>&lt;T, U&gt; pfr::lt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for less-than using their own comparison and conversion operators; if no operators avalable returns \forcedlink{lt_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is less than rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#aa363e8c1946f33a73b5d1ab84f99d163">pfr::lt_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_aa363e8c1946f33a73b5d1ab84f99d163"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#aa363e8c1946f33a73b5d1ab84f99d163">pfr::lt_fields</a></div><div class="ttdeci">constexpr bool lt_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00072">ops_fields.hpp:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa363e8c1946f33a73b5d1ab84f99d163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa363e8c1946f33a73b5d1ab84f99d163">&#9670;&nbsp;</a></span>lt_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::lt_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field less comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt; tuple_size_v&lt;U&gt;)</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00072">72</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::less_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a365061baaca2655bbed16d395f658943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365061baaca2655bbed16d395f658943">&#9670;&nbsp;</a></span>ne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#a8f8edab77e7b9b4f08371b0e495836c1">detail::enable_ne_comp_t</a>&lt;T, U&gt; pfr::ne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00095">95</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">return</span> lhs != rhs;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aca529814463f7e95184f1390385af8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca529814463f7e95184f1390385af8dc">&#9670;&nbsp;</a></span>ne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d07/namespacepfr_1_1detail.html#aa4cfc747df3957e8d03ce6ee8bab1294">detail::enable_not_ne_comp_t</a>&lt;T, U&gt; pfr::ne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for inequality using their own comparison and conversion operators; if no operators avalable returns \forcedlink{ne_fields}(lhs, rhs). </p>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is not equal to rhs; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d05/ops_8hpp_source.html#l00089">89</a> of file <a class="el" href="../../d6/d05/ops_8hpp_source.html">ops.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d4/d26/namespacepfr.html#a171d46ae2f6c074ad43b3837746f2a75">pfr::ne_fields</a>(lhs, rhs);</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_html_a171d46ae2f6c074ad43b3837746f2a75"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a171d46ae2f6c074ad43b3837746f2a75">pfr::ne_fields</a></div><div class="ttdeci">constexpr bool ne_fields(const T &amp;lhs, const U &amp;rhs) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d0a/ops__fields_8hpp_source.html#l00052">ops_fields.hpp:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a171d46ae2f6c074ad43b3837746f2a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171d46ae2f6c074ad43b3837746f2a75">&#9670;&nbsp;</a></span>ne_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pfr::ne_fields </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a field-by-field inequality comparison.</p>
<dl class="section return"><dt>Returns</dt><dd><code>L != R || tuple_size_v&lt;T&gt; != tuple_size_v&lt;U&gt;</code>, where <code>L</code> and <code>R</code> are the results of calling <code>std::tie</code> on first <code>N</code> fields of <code>lhs</code> and </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../d7/d0a/ops__fields_8hpp_source.html">ops_fields.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordflow">return</span> detail::binary_visit&lt;detail::not_equal_impl&gt;(lhs, rhs);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3adc9d30f52fbb7567415da40ad94349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adc9d30f52fbb7567415da40ad94349">&#9670;&nbsp;</a></span>structure_tie() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::structure_tie </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tie` like function that ties fields of a structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a <code>std::tuple</code> with lvalue and const lvalue references to fields of an \aggregate <code>val</code>.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp;, <span class="keyword">const</span> <span class="keywordtype">short</span>&amp;);</div>
<div class="line"><span class="keyword">struct </span>my_struct { <span class="keywordtype">int</span> i, <span class="keywordtype">short</span> s; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> my_struct const_s{1, 2};</div>
<div class="line">std::apply(foo, <a class="code" href="../../d4/d26/namespacepfr.html#a3adc9d30f52fbb7567415da40ad94349">pfr::structure_tie</a>(const_s));</div>
<div class="line"> </div>
<div class="line">my_struct s;</div>
<div class="line"><a class="code" href="../../d4/d26/namespacepfr.html#a3adc9d30f52fbb7567415da40ad94349">pfr::structure_tie</a>(s) = std::tuple&lt;int, short&gt;{10, 11};</div>
<div class="line">assert(s.s == 11);</div>
<div class="ttc" id="anamespacepfr_html_a3adc9d30f52fbb7567415da40ad94349"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a3adc9d30f52fbb7567415da40ad94349">pfr::structure_tie</a></div><div class="ttdeci">constexpr auto structure_tie(const T &amp;val) noexcept</div><div class="ttdoc">std::tie` like function that ties fields of a structure.</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d47/core_8hpp_source.html#l00161">core.hpp:161</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00161">161</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#acb270942e947c9e15b3fdd4b8cd40847">detail::make_conststdtiedtuple_from_tietuple</a>(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(<span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(val)), <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ab0796d8dffdae14a3769d81b541def9e">detail::make_index_sequence</a>&lt;tuple_size_v&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_ab0796d8dffdae14a3769d81b541def9e"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#ab0796d8dffdae14a3769d81b541def9e">pfr::detail::make_index_sequence</a></div><div class="ttdeci">make_integer_sequence&lt; std::size_t, N &gt; make_index_sequence</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d99/make__integer__sequence_8hpp_source.html#l00080">make_integer_sequence.hpp:80</a></div></div>
<div class="ttc" id="anamespacepfr_1_1detail_html_acb270942e947c9e15b3fdd4b8cd40847"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#acb270942e947c9e15b3fdd4b8cd40847">pfr::detail::make_conststdtiedtuple_from_tietuple</a></div><div class="ttdeci">constexpr auto make_conststdtiedtuple_from_tietuple(const T &amp;t, std::index_sequence&lt; I... &gt;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dee/stdtuple_8hpp_source.html#l00032">stdtuple.hpp:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8974aa361c400a576ef9193d6cffd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8974aa361c400a576ef9193d6cffd40">&#9670;&nbsp;</a></span>structure_tie() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::structure_tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00190">190</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        static_assert(<span class="keyword">sizeof</span>(T) &amp;&amp; <span class="keyword">false</span>, <span class="stringliteral">&quot;====================&gt; Boost.PFR: Calling pfr::structure_tie on rvalue references is forbidden&quot;</span>);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe8fb6fb205d497c54085adb6ea932f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8fb6fb205d497c54085adb6ea932f2">&#9670;&nbsp;</a></span>structure_tie() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::structure_tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00181">181</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    {</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        static_assert(</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keyword">sizeof</span>(T) &amp;&amp; <span class="keyword">false</span>, <span class="stringliteral">&quot;====================&gt; Boost.PFR: Calling pfr::structure_tie on non const non assignable type is allowed only in C++17&quot;</span>);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f0e0814a4fdddddd54f03f5e87c9c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0e0814a4fdddddd54f03f5e87c9c24">&#9670;&nbsp;</a></span>structure_tie() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::structure_tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00168">168</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ab6954467d7c6df95754517a9473e3e03">detail::make_stdtiedtuple_from_tietuple</a>(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val), <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ab0796d8dffdae14a3769d81b541def9e">detail::make_index_sequence</a>&lt;tuple_size_v&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_ab6954467d7c6df95754517a9473e3e03"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#ab6954467d7c6df95754517a9473e3e03">pfr::detail::make_stdtiedtuple_from_tietuple</a></div><div class="ttdeci">constexpr auto make_stdtiedtuple_from_tietuple(const T &amp;t, std::index_sequence&lt; I... &gt;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dee/stdtuple_8hpp_source.html#l00027">stdtuple.hpp:27</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a02731b2fc23581c2b67b9889451ccb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02731b2fc23581c2b67b9889451ccb6a">&#9670;&nbsp;</a></span>structure_to_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pfr::structure_to_tuple </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>std::tuple</code> from fields of an \aggregate <code>val</code>. </p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_struct { <span class="keywordtype">int</span> i, <span class="keywordtype">short</span> s; };</div>
<div class="line">my_struct s {10, 11};</div>
<div class="line">std::tuple&lt;int, short&gt; t = <a class="code" href="../../d4/d26/namespacepfr.html#a02731b2fc23581c2b67b9889451ccb6a">pfr::structure_to_tuple</a>(s);</div>
<div class="line">assert(get&lt;0&gt;(t) == 10);</div>
<div class="ttc" id="anamespacepfr_html_a02731b2fc23581c2b67b9889451ccb6a"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a02731b2fc23581c2b67b9889451ccb6a">pfr::structure_to_tuple</a></div><div class="ttdeci">constexpr auto structure_to_tuple(const T &amp;val) noexcept</div><div class="ttdoc">Creates a std::tuple from fields of an \aggregate val.</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d47/core_8hpp_source.html#l00140">core.hpp:140</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00140">140</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#a17a3135d23860038bf06a7725dd36b38">detail::make_stdtuple_from_tietuple</a>(<a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ae4a6f202c475b551fd2a84a8cc35c9c5">detail::tie_as_tuple</a>(val), <a class="code" href="../../d9/d07/namespacepfr_1_1detail.html#ab0796d8dffdae14a3769d81b541def9e">detail::make_index_sequence</a>&lt;tuple_size_v&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    }</div>
<div class="ttc" id="anamespacepfr_1_1detail_html_a17a3135d23860038bf06a7725dd36b38"><div class="ttname"><a href="../../d9/d07/namespacepfr_1_1detail.html#a17a3135d23860038bf06a7725dd36b38">pfr::detail::make_stdtuple_from_tietuple</a></div><div class="ttdeci">constexpr auto make_stdtuple_from_tietuple(const T &amp;t, std::index_sequence&lt; I... &gt;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dee/stdtuple_8hpp_source.html#l00022">stdtuple.hpp:22</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a11d4b2ba9c7e94a210ea381971bb3499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d4b2ba9c7e94a210ea381971bb3499">&#9670;&nbsp;</a></span>tie_from_structure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Elements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d6/ddb/structpfr_1_1detail_1_1tie__from__structure__tuple.html">detail::tie_from_structure_tuple</a>&lt;Elements...&gt; pfr::tie_from_structure </td>
          <td>(</td>
          <td class="paramtype">Elements &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tie-like function that allows assigning to tied values from aggregates. </p>
<dl class="section return"><dt>Returns</dt><dd>an object with lvalue references to <code>args...</code>; on assignment of an \aggregate value to that object each field of an aggregate is assigned to the corresponding <code>args...</code> reference.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> f() {</div>
<div class="line">  <span class="keyword">struct </span>{ <span class="keyword">struct </span>{ <span class="keywordtype">int</span> x, y } <a class="code" href="../../db/d92/namespacewebframe_1_1_o_r_m_1_1impl.html#a695796b1e067c34fd237703da0c785e6">p</a>; <span class="keywordtype">short</span> s; } res { { 4, 5 }, 6 };</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> [<a class="code" href="../../db/d92/namespacewebframe_1_1_o_r_m_1_1impl.html#a695796b1e067c34fd237703da0c785e6">p</a>, s] = f();</div>
<div class="line"><a class="code" href="../../d4/d26/namespacepfr.html#a11d4b2ba9c7e94a210ea381971bb3499">pfr::tie_from_structure</a>(<a class="code" href="../../db/d92/namespacewebframe_1_1_o_r_m_1_1impl.html#a695796b1e067c34fd237703da0c785e6">p</a>, s) = f();</div>
<div class="ttc" id="anamespacepfr_html_a11d4b2ba9c7e94a210ea381971bb3499"><div class="ttname"><a href="../../d4/d26/namespacepfr.html#a11d4b2ba9c7e94a210ea381971bb3499">pfr::tie_from_structure</a></div><div class="ttdeci">constexpr detail::tie_from_structure_tuple&lt; Elements... &gt; tie_from_structure(Elements &amp;... args) noexcept</div><div class="ttdoc">std::tie-like function that allows assigning to tied values from aggregates.</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d47/core_8hpp_source.html#l00242">core.hpp:242</a></div></div>
<div class="ttc" id="anamespacewebframe_1_1_o_r_m_1_1impl_html_a695796b1e067c34fd237703da0c785e6"><div class="ttname"><a href="../../db/d92/namespacewebframe_1_1_o_r_m_1_1impl.html#a695796b1e067c34fd237703da0c785e6">webframe::ORM::impl::p</a></div><div class="ttdeci">p</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d99/db__type__wrappers_8hpp_source.html#l00244">db_type_wrappers.hpp:245</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../da/d47/core_8hpp_source.html#l00242">242</a> of file <a class="el" href="../../da/d47/core_8hpp_source.html">core.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">return</span> detail::tie_from_structure_tuple&lt;Elements...&gt;(args...);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e6c3763a793e6e07d1341337db70925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6c3763a793e6e07d1341337db70925">&#9670;&nbsp;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t pfr::tuple_size_v = <a class="el" href="../../d4/d26/namespacepfr.html#a8b9aaaded645f54bdd6373947424b576">tuple_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>tuple_size_v</code> is a template variable that contains fields count in a T and works for any T that satisfies \aggregate.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">std::array&lt;int, pfr::tuple_size_v&lt;my_structure&gt; &gt; a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../d4/d41/tuple__size_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../d4/d41/tuple__size_8hpp_source.html">tuple_size.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
